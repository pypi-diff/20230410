# Comparing `tmp/fw_gear_dcm2niix-1.4.1-py3-none-any.whl.zip` & `tmp/fw_gear_dcm2niix-2.0.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,18 +1,17 @@
-Zip file size: 25221 bytes, number of entries: 16
--rw-r--r--  2.0 unx       33 b- defN 80-Jan-01 00:00 fw_gear_dcm2niix/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 fw_gear_dcm2niix/dcm2niix/__init__.py
--rw-r--r--  2.0 unx    14468 b- defN 80-Jan-01 00:00 fw_gear_dcm2niix/dcm2niix/arrange.py
--rw-r--r--  2.0 unx     7570 b- defN 80-Jan-01 00:00 fw_gear_dcm2niix/dcm2niix/dcm2niix_run.py
--rw-r--r--  2.0 unx     5776 b- defN 80-Jan-01 00:00 fw_gear_dcm2niix/dcm2niix/dcm2niix_utils.py
--rw-r--r--  2.0 unx     2371 b- defN 80-Jan-01 00:00 fw_gear_dcm2niix/dcm2niix/interfaces.py
+Zip file size: 25276 bytes, number of entries: 15
+-rw-r--r--  2.0 unx      192 b- defN 80-Jan-01 00:00 fw_gear_dcm2niix/__init__.py
+-rw-r--r--  2.0 unx       27 b- defN 80-Jan-01 00:00 fw_gear_dcm2niix/dcm2niix/__init__.py
+-rw-r--r--  2.0 unx    14361 b- defN 80-Jan-01 00:00 fw_gear_dcm2niix/dcm2niix/arrange.py
+-rw-r--r--  2.0 unx     7642 b- defN 80-Jan-01 00:00 fw_gear_dcm2niix/dcm2niix/dcm2niix_run.py
+-rw-r--r--  2.0 unx     5646 b- defN 80-Jan-01 00:00 fw_gear_dcm2niix/dcm2niix/dcm2niix_utils.py
+-rw-r--r--  2.0 unx     3528 b- defN 80-Jan-01 00:00 fw_gear_dcm2niix/dcm2niix/interfaces.py
 -rw-r--r--  2.0 unx     1240 b- defN 80-Jan-01 00:00 fw_gear_dcm2niix/dcm2niix/prepare.py
--rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 fw_gear_dcm2niix/pydeface/__init__.py
--rw-r--r--  2.0 unx     5096 b- defN 80-Jan-01 00:00 fw_gear_dcm2niix/pydeface/pydeface_run.py
--rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 fw_gear_dcm2niix/utils/__init__.py
--rw-r--r--  2.0 unx    16344 b- defN 80-Jan-01 00:00 fw_gear_dcm2niix/utils/metadata.py
--rw-r--r--  2.0 unx     8428 b- defN 80-Jan-01 00:00 fw_gear_dcm2niix/utils/parse_config.py
--rw-r--r--  2.0 unx     7965 b- defN 80-Jan-01 00:00 fw_gear_dcm2niix/utils/resolve.py
-?rw-r--r--  2.0 unx       83 b- defN 16-Jan-01 00:00 fw_gear_dcm2niix-1.4.1.dist-info/WHEEL
-?rw-r--r--  2.0 unx    10806 b- defN 16-Jan-01 00:00 fw_gear_dcm2niix-1.4.1.dist-info/METADATA
-?rw-r--r--  2.0 unx     1443 b- defN 16-Jan-01 00:00 fw_gear_dcm2niix-1.4.1.dist-info/RECORD
-16 files, 81623 bytes uncompressed, 22793 bytes compressed:  72.1%
+-rw-r--r--  2.0 unx       24 b- defN 80-Jan-01 00:00 fw_gear_dcm2niix/utils/__init__.py
+-rw-r--r--  2.0 unx    15016 b- defN 80-Jan-01 00:00 fw_gear_dcm2niix/utils/metadata.py
+-rw-r--r--  2.0 unx     7078 b- defN 80-Jan-01 00:00 fw_gear_dcm2niix/utils/parse_config.py
+-rw-r--r--  2.0 unx     6904 b- defN 80-Jan-01 00:00 fw_gear_dcm2niix/utils/resolve.py
+-rw-r--r--  2.0 unx     1092 b- defN 80-Jan-01 00:00 fw_gear_dcm2niix-2.0.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx    13561 b- defN 80-Jan-01 00:00 fw_gear_dcm2niix-2.0.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       88 b- defN 80-Jan-01 00:00 fw_gear_dcm2niix-2.0.0.dist-info/WHEEL
+?rw-r--r--  2.0 unx     1354 b- defN 16-Jan-01 00:00 fw_gear_dcm2niix-2.0.0.dist-info/RECORD
+15 files, 77753 bytes uncompressed, 23000 bytes compressed:  70.4%
```

## zipnote {}

```diff
@@ -15,35 +15,32 @@
 
 Filename: fw_gear_dcm2niix/dcm2niix/interfaces.py
 Comment: 
 
 Filename: fw_gear_dcm2niix/dcm2niix/prepare.py
 Comment: 
 
-Filename: fw_gear_dcm2niix/pydeface/__init__.py
-Comment: 
-
-Filename: fw_gear_dcm2niix/pydeface/pydeface_run.py
-Comment: 
-
 Filename: fw_gear_dcm2niix/utils/__init__.py
 Comment: 
 
 Filename: fw_gear_dcm2niix/utils/metadata.py
 Comment: 
 
 Filename: fw_gear_dcm2niix/utils/parse_config.py
 Comment: 
 
 Filename: fw_gear_dcm2niix/utils/resolve.py
 Comment: 
 
-Filename: fw_gear_dcm2niix-1.4.1.dist-info/WHEEL
+Filename: fw_gear_dcm2niix-2.0.0.dist-info/LICENSE
+Comment: 
+
+Filename: fw_gear_dcm2niix-2.0.0.dist-info/METADATA
 Comment: 
 
-Filename: fw_gear_dcm2niix-1.4.1.dist-info/METADATA
+Filename: fw_gear_dcm2niix-2.0.0.dist-info/WHEEL
 Comment: 
 
-Filename: fw_gear_dcm2niix-1.4.1.dist-info/RECORD
+Filename: fw_gear_dcm2niix-2.0.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## fw_gear_dcm2niix/__init__.py

```diff
@@ -1 +1,8 @@
-"""The dcm2niix Gear package."""
+"""The fw_gear_dcm2niix package."""
+from importlib.metadata import version
+
+try:
+    __version__ = version(__package__)
+# pylint: disable-next=bare-except
+except:  # pragma: no cover
+    pass
```

## fw_gear_dcm2niix/dcm2niix/__init__.py

```diff
@@ -0,0 +1,2 @@
+00000000: 2222 2264 636d 326e 6969 7820 7375 622d  """dcm2niix sub-
+00000010: 6d6f 6475 6c65 2e22 2222 0a              module.""".
```

## fw_gear_dcm2niix/dcm2niix/arrange.py

```diff
@@ -29,54 +29,50 @@
         dcm2niix_input_dir (str): The absolute path to the output directory containing
             the files from the input(s).
 
     """
     log.info("Arrange dcm2niix input.")
 
     if zipfile.is_zipfile(infile):
-
         try:
-
             with zipfile.ZipFile(infile, "r") as zip_obj:
-                log.info(f"Establishing input as zip file: {infile}")
+                log.info("Establishing input as zip file: %s", infile)
                 exit_if_archive_empty(zip_obj)
                 dcm2niix_input_dir = extract_archive_contents(zip_obj, work_dir)
 
         except zipfile.BadZipFile:
             log.exception(
                 (
                     "Incorrect gear input. "
                     "File is not a zip archive file (.zip). Exiting."
                 )
             )
             os.sys.exit(1)
 
     elif tarfile.is_tarfile(infile):
-
         try:
             with tarfile.open(infile, "r") as tar_obj:
-                log.info(f"Establishing input as tar file: {infile}")
+                log.info("Establishing input as tar file: %s", infile)
                 exit_if_archive_empty(tar_obj)
                 dcm2niix_input_dir = extract_archive_contents(tar_obj, work_dir)
 
         except tarfile.ReadError:
             log.exception(
                 (
                     "Incorrect gear input. "
                     "File is not a compressed tar archive file (.tgz). Exiting."
                 )
             )
             os.sys.exit(1)
 
     elif rec_infile:
-        log.info(f"Establishing input as par/rec file pair: {infile} & {rec_infile}")
+        log.info("Establishing input as par/rec file pair: %s & %s", infile, rec_infile)
 
         # If a REC file input was provided, check infile for a valid PAR file
         if infile.lower().endswith("par") and rec_infile.lower().endswith("rec"):
-
             dcm2niix_input_dir, dirname = setup_dcm2niix_input_dir(infile, work_dir)
             shutil.copy2(rec_infile, dcm2niix_input_dir)
             shutil.copy2(infile, dcm2niix_input_dir)
             adjust_parrec_filenames(dcm2niix_input_dir, dirname)
 
         else:
             log.error(
@@ -96,104 +92,107 @@
     log.info("Input for dcm2niix prepared successfully.")
 
     return dcm2niix_input_dir
 
 
 def exit_if_archive_empty(archive_obj):
     """If the archive contents are empty, log an error and exit."""
-    if type(archive_obj) == zipfile.ZipFile:
-        size_contents = sum([zipinfo.file_size for zipinfo in archive_obj.filelist])
+    if isinstance(archive_obj, zipfile.ZipFile):
+        size_contents = sum(zipinfo.file_size for zipinfo in archive_obj.filelist)
 
-    elif type(archive_obj) == tarfile.TarFile:
-        size_contents = sum([tarinfo.size for tarinfo in archive_obj.getmembers()])
+    elif isinstance(archive_obj, tarfile.TarFile):
+        size_contents = sum(tarinfo.size for tarinfo in archive_obj.getmembers())
 
     else:
         log.info(
             "Unsupported archive format. Unable to establish size of input archive. Exiting."
         )
         os.sys.exit(1)
 
     if size_contents == 0:
         log.error("Incorrect gear input. Input archive is empty. Exiting.")
         os.sys.exit(1)
 
 
 def tally_files(dir_loc):
-    """Function to profile directory. Note current exclusion of {'\.DS_Store.*', '^\._.*'}
-    from file_set and file_tree. # TODO move this exclusion?
+    r"""Function to profile directory.
+
+    Note current exclusion of {'\.DS_Store.*', '^\._.*'} from file_set and file_tree.
+    # TODO move this exclusion?
 
     Args:
         dir_loc (str): path to directory to profile
     Returns:
         file_set (set): set of file leaves that pass the regex criteria
         file_tree (list): list showing full filepaths of all files
         file_name_path_dict (dict): dict mapping from filenames that pass
          the regex criteria to full filepath
     """
-
     file_set = set()
     file_name_path_dict = {}
     file_tree = []
     file_tree_full = []
     gen = os.walk(dir_loc, topdown=True)
     next_gen = next(gen)
     # want to exclude files matching certain patterns str_to_exclude
+    # pylint: disable-next=anomalous-backslash-in-string
     strs_to_exclude = ["^\..*"]
     excludes = [re.compile(s) for s in strs_to_exclude]
     while True:
-
         # info on current folder and contents
-        (loc_i, dirs_i, files_i) = next_gen
+        (loc_i, _, files_i) = next_gen
 
         for file_ij in files_i:
-
             # if filename doesn't match any of the exclude patterns:
-            if not any([exclude.search(file_ij) for exclude in excludes]):
+            if not any(exclude.search(file_ij) for exclude in excludes):
                 # avoid collisions from collapsing filepaths
-                if file_ij in file_name_path_dict.keys():
+                if file_ij in file_name_path_dict:
                     log.error(
-                        f"more than one file with name of {file_ij} in directory tree, exiting."
+                        "more than one file with name of %s in directory tree, exiting.",
+                        file_ij,
                     )
                     os.sys.exit(1)
 
                 # set of files (short paths or leaves) found in directory
                 file_set = file_set | set([file_ij])
 
                 # dictionary to look up full file paths
                 file_name_path_dict[file_ij] = os.path.join(loc_i, file_ij)
 
                 # directory structure in list form, filter on files
                 file_tree.append(os.path.join(loc_i, file_ij))
 
             else:
-                log.info(f"excluding file {file_ij} from all but file_tree_full.")
+                log.info("excluding file %s from all but file_tree_full.", file_ij)
 
             # directory structure in list form, no filter on files
             file_tree_full.append(os.path.join(loc_i, file_ij))
 
         # info for debugging log
         log.debug(
-            f"file_set: {file_set}"
-            f"file_tree: {file_tree}"
-            f"file_tree_full: {file_tree_full}"
-            f"file_name_path_dict: {file_name_path_dict}"
+            "file_set: %s; file_tree: %s; file_tree_full: %s; file_name_path_dict: %s",
+            file_set,
+            file_tree,
+            file_tree_full,
+            file_name_path_dict,
         )
 
         # next folder:
         try:
             next_gen = next(gen)
         except StopIteration:
             break
 
     return file_set, file_tree, file_tree_full, file_name_path_dict
 
 
 def flatten_directory(dir_source, dir_target, overwrite=False):
-    """Takes input directory and creates corresponding output directory
-     with relevant files all at one level.
+    """Takes input directory and creates corresponding output directory.
+
+     Output directory created with relevant files all at one level.
 
     Args:
         dir_source (str): possibly nested source
         dir_target (str): place to create flat file structure
         overwrite (bool): if True overwrite files if they already exist
 
     Returns:
@@ -205,120 +204,106 @@
 
         info on target directory
             file_set_target (set): set of file leaves that pass the regex criteria
             file_tree_target (list): list showing full filepaths of all files
             file_name_path_dict_target (dict): dict mapping from filenames that pass
              the regex criteria to full filepath
     """
-    # TODO maybe write test for overwriting
 
     # source directory tally
-    (
-        file_set_source,
-        file_tree_source,
-        file_tree_full_source,
-        file_name_path_dict_source,
-    ) = tally_files(dir_source)
+    (_, file_tree_source, _, file_name_path_dict_source) = tally_files(dir_source)
 
     # check for already existing/clear way for target directory
     if os.path.exists(dir_target):
-        if overwrite is True:
-            shutil.rmtree(dir_target)
-        else:
-            log.error(f"file {dir_target} already exists, exiting.")
+        if overwrite is False:
+            log.error("file %s already exists, exiting.", dir_target)
             os.sys.exit(1)
+        # else:
+        shutil.rmtree(dir_target)
     os.mkdir(dir_target)
 
     # the main part, move the files from the possibly hierarchical structure
     # to the flat structure
-    for file in file_name_path_dict_source.keys():
-        shutil.move(file_name_path_dict_source[file], dir_target)
+    for _, file_source in file_name_path_dict_source.items():
+        shutil.move(file_source, dir_target)
 
     # target directory tally
-    (
-        file_set_target,
-        file_tree_target,
-        file_tree_full_target,
-        file_name_path_dict_target,
-    ) = tally_files(dir_target)
+    (_, file_tree_target, _, _) = tally_files(dir_target)
 
     # log before/after
     file_tree_source_str = "\n".join(file_tree_source)
     file_tree_target_str = "\n".join(file_tree_target)
     log.info(
-        f"\n\nfile_tree_source:\n{file_tree_source_str}\n"
-        f"\nfile_tree_target:\n{file_tree_target_str}\n\n"
+        "\n\nfile_tree_source:\n%s\n\nfile_tree_target:\n%s\n\n",
+        file_tree_source_str,
+        file_tree_target_str,
     )
 
 
 def extract_archive_contents(archive_obj, work_dir):
     """Extract archive contents to a directory created from the input filename."""
     # 1. Get the stage for zip or tar archive
-    if type(archive_obj) == zipfile.ZipFile:
+    if isinstance(archive_obj, zipfile.ZipFile):
         subdirs = [info.filename for info in archive_obj.infolist() if info.is_dir()]
         filename = archive_obj.filename
         filelist = archive_obj.namelist()
 
-    elif type(archive_obj) == tarfile.TarFile:
+    elif isinstance(archive_obj, tarfile.TarFile):
         subdirs = [info.name for info in archive_obj.getmembers() if info.isdir()]
         filename = archive_obj.name
         filelist = archive_obj.getnames()
 
     # 2. Extract archive contents to directory
     if len(subdirs) == 0:
-
         # Input filename will be used as the dcm2niix input directory name
         dcm2niix_input_dir, dirname = setup_dcm2niix_input_dir(filename, work_dir)
         archive_obj.extractall(dcm2niix_input_dir)
 
     elif len(subdirs) >= 1:
-
         # Subdirectory name will be used as the dcm2niix input directory name
-        log.info(f"subdirs: {subdirs}")
+        log.info("subdirs: %s", subdirs)
         dcm2niix_input_dir, dirname = setup_dcm2niix_input_dir(subdirs[0], work_dir)
-        log.info(f"dcm2niix_input_dir: {dcm2niix_input_dir}")
+        log.info("dcm2niix_input_dir: %s", dcm2niix_input_dir)
 
         # set temp directory to extract to, before flattening output contents
         dcm2niix_input_dir_o = dcm2niix_input_dir + "_o"
 
         # clean slate
         if os.path.exists(dcm2niix_input_dir):
             shutil.rmtree(dcm2niix_input_dir)
         if os.path.exists(dcm2niix_input_dir_o):
             shutil.rmtree(dcm2niix_input_dir_o)
 
         # site for initial extraction
         os.mkdir(dcm2niix_input_dir_o)
 
         # extract
-        if type(archive_obj) == zipfile.ZipFile:
+        if isinstance(archive_obj, zipfile.ZipFile):
             for subdir in subdirs:
                 archive_obj.extractall(
                     dcm2niix_input_dir_o, strip_prefix_ziparchive(archive_obj, subdir)
                 )
-        elif type(archive_obj) == tarfile.TarFile:
+        elif isinstance(archive_obj, tarfile.TarFile):
             for subdir in subdirs:
                 archive_obj.extractall(
                     dcm2niix_input_dir_o, strip_prefix_tararchive(archive_obj, subdir)
                 )
 
         # flattening: take file leaves in dcm2niix_input_dir_o and move them dcm2niix_input_dir
         flatten_directory(dcm2niix_input_dir_o, dcm2niix_input_dir)
 
         # clean up
         shutil.rmtree(dcm2niix_input_dir_o)
 
     else:
-
         # if input packaging falls into none of above categories, not supported, exit
         log.error(
-            (
-                "Incorrect gear input. Input archive packaging is not supported. "
-                f"Detected subdirs in archive: {subdirs}. Exiting."
-            )
+            "Incorrect gear input. Input archive packaging is not supported. "
+            "Detected subdirs in archive: %s. Exiting.",
+            subdirs,
         )
         os.sys.exit(1)
 
     # 3. If PAR file in the archive, then adjust par/rec filenames
     if [file for file in filelist if file.lower().endswith(".par")]:
         adjust_parrec_filenames(dcm2niix_input_dir, dirname)
 
@@ -366,30 +351,28 @@
 
     return filename
 
 
 def strip_prefix_ziparchive(zip_obj, prefix):
     """Modify a filepath in a zip archive without the prefix."""
     for zipinfo in zip_obj.infolist():
-
         if (
             zipinfo.filename.startswith(prefix)
             and os.path.splitext(zipinfo.filename)[0] != prefix
         ):
             zipinfo.filename = zipinfo.filename[len(prefix) :]
 
         # Only return files
         if not zipinfo.is_dir():
             yield zipinfo
 
 
 def strip_prefix_tararchive(tar_obj, prefix):
     """Modify a filepath in a tar archive without the prefix."""
     for tarinfo in tar_obj.getmembers():
-
         if (
             tarinfo.path.startswith(prefix)
             and os.path.splitext(tarinfo.path)[0] != prefix
         ):
             tarinfo.path = tarinfo.path[len(prefix) + 1 :]
 
         # Only return files
```

## fw_gear_dcm2niix/dcm2niix/dcm2niix_run.py

```diff
@@ -28,14 +28,15 @@
     merge2d=2,
     output_nrrd=False,
     philips_scaling=True,
     single_file_mode=False,
     text_notes_private=False,
     verbose=False,
 ):
+    # pylint: disable=too-many-arguments,too-many-locals,too-many-statements
     """Run dcm2niix.
 
     Args:
         source_dir (str): The absolute path to the output directory containing
             the files from the input(s).
         output_dir (str): The absolute path to the output directory to place the
             converted results.
@@ -72,25 +73,22 @@
     Returns:
         output (nipype.interfaces.base.support.InterfaceResult): The dcm2niix
             output results.
 
     """
     try:
         converter = Dcm2niixEnhanced()
-        log.info(f"Starting dcm2niix {converter.version}")
-        log.info(f"Submitting {len(os.listdir(source_dir))} DICOMs.")
+        log.info("Starting dcm2niix %s", converter.version)
+        log.info("Submitting %d DICOMs.", len(os.listdir(source_dir)))
 
         converter.inputs.source_dir = source_dir
         converter.inputs.output_dir = output_dir
 
         # dcm2niix command configurations for: anonymize_bids, bids_sidecar
-        if bids_sidecar == "o":
-            converter.inputs.bids_format = True
-            converter.inputs.anon_bids = anonymize_bids
-        elif bool(util.strtobool(bids_sidecar)):
+        if bids_sidecar == "o" or bool(util.strtobool(bids_sidecar)):
             converter.inputs.bids_format = True
             converter.inputs.anon_bids = anonymize_bids
         else:
             log.info("The BIDS sidecar file will not be generated.")
             converter.inputs.bids_format = False
 
         # dcm2niix command configurations for: comment
@@ -105,36 +103,36 @@
             )
             filename = "%p_%s"
 
         if str(compress_images) in ["y", "i", "n", "3"]:
             converter.inputs.compress = str(compress_images)
 
             # dcm2niix command configurations for: compression_level
-            if (
-                (compression_level > 0)
-                and (compression_level < 10)
-                and isinstance(compression_level, int)
+            if not (
+                (0 < compression_level < 10) and isinstance(compression_level, int)
             ):
-                converter.inputs.compression = compression_level
-            else:
                 log.error(
-                    "Configuration option error: compression_level must be between 1 and 9. Exiting."
+                    "Configuration option error: compression_level must be an integer "
+                    "between 1 and 9; got: value: %s, %s. Exiting.",
+                    compression_level,
+                    type(compression_level),
                 )
                 os.sys.exit(1)
+            converter.inputs.compression = compression_level
 
         # dcm2niix command configurations for: convert_only_series
         if convert_only_series != "all":
             log.warning(
                 "Expert Option (convert_only_series). "
                 "We trust that since you have selected this option "
                 "you know what you are asking for. "
                 "Continuing."
             )
 
-            # See: https://www.nitrc.org/forum/forum.php?thread_id=11134&forum_id=4703
+            # See: https://www.nitrc.org/forum/forum.php?forum_id=4703&thread_id=11134
             converter.inputs.series_numbers = convert_only_series
 
         # dcm2niix command configurations for: crop
         converter.inputs.crop = crop
 
         # dcm2niix command configurations for: filename
         converter.inputs.out_filename = filename.replace(" ", "_")
@@ -161,36 +159,36 @@
         # dcm2niix command configurations for: text_notes_private
         converter.inputs.has_private = text_notes_private
 
         # dcm2niix command configurations for: verbose
         converter.inputs.verbose = verbose
 
         # Log the dcm2niix command configuration and run
-        log.info(f"Command to be executed: \n\n{converter.cmdline}\n")
+        log.info("Command to be executed: \n\n%s\n", converter.cmdline)
         output = converter.run()
 
-        log.info(f"Output from dcm2niix: \n\n{output.runtime.stdout }\n")
+        log.info("Output from dcm2niix: \n\n%s\n", output.runtime.stdout)
 
         # If error from dcm2niix tool, then raise exception
         if int(output.runtime.returncode) == 1:
+            # pylint: disable-next=broad-exception-raised
             raise Exception("The dcm2niix software tool returned an error.")
-        else:
-            log.info("Finished dcm2niix conversion.")
+        log.info("Finished dcm2niix conversion.")
 
+    # pylint: disable-next=broad-except
     except Exception as e:
-
         log.error("Did not complete dcm2niix conversion properly.")
         log.exception(e, exc_info=False)
 
         # dcm2niix command configurations for: ignore_errors
         if not ignore_errors:
             log.error("Exiting.")
             os.sys.exit(1)
-        else:
-            log.warning(
-                "Expert Option (ignore_errors). "
-                "We trust that since you have selected this option "
-                "you know what you are asking for. "
-                "Continuing."
-            )
+
+        log.warning(
+            "Expert Option (ignore_errors). "
+            "We trust that since you have selected this option "
+            "you know what you are asking for. "
+            "Continuing."
+        )
 
     return output
```

## fw_gear_dcm2niix/dcm2niix/dcm2niix_utils.py

```diff
@@ -17,38 +17,37 @@
     Args:
         dcm2niix_input_dir (str): The absolute path to a set of dicoms.
 
     Returns:
         None; removes dicoms from dcm2niix_input_dir.
 
     """
-    n_dicom_files = len(glob.glob(dcm2niix_input_dir + "/*"))
     log.info(
-        f"Running incomplete volume correction. {n_dicom_files} dicom files found."
+        "Running incomplete volume correction. %d dicom files found.",
+        len(glob.glob(dcm2niix_input_dir + "/*")),
     )
     script = f"{os.getenv('FLYWHEEL')}/fix_dcm_vols.py"
     command = ["python3", script, dcm2niix_input_dir]
-    log.info(f"Command to be executed: {' '.join(command)}")
+    log.info("Command to be executed: %s", " ".join(command))
 
-    process = subprocess.Popen(
+    # pylint: disable=duplicate-code
+    with subprocess.Popen(
         command,
         stdout=subprocess.PIPE,
         stderr=subprocess.STDOUT,
         universal_newlines=True,
-    )
-
-    with process.stdout:
+    ) as process:
+        # pylint: enable=duplicate-code
         log.info(
-            "Output from incomplete volume correction:" f"\n\n{process.stdout.read()}\n"
+            "Output from incomplete volume correction: \n\n%s\n", process.stdout.read()
         )
-
-    if process.wait() != 0:
-        log.error("Incomplete volume removal script failed. Exiting.")
-        os.sys.exit(1)
-    else:
+        if process.wait() != 0:
+            log.error("Incomplete volume removal script failed. Exiting.")
+            os.sys.exit(1)
+        # else
         log.info("Success.")
 
         # If missing volumes found, two directories (corrected_dcm and orphan_dcm)
         # in the dcm2niix input directory are created.
         corrected_dcm_dir = os.path.join(dcm2niix_input_dir, "corrected_dcm")
         orphan_dcm = "/".join([dcm2niix_input_dir, "orphan_dcm"])
 
@@ -61,41 +60,34 @@
 
             if len(subdirs) != 2:
                 log.error(
                     "Output from incomplete volume removal script is unexpected. "
                     "Exiting."
                 )
                 os.sys.exit(1)
+            # else:
+            # If dcm2niix input directory is empty:
+            # 1. Remove orphan directory
+            shutil.rmtree(orphan_dcm)
+
+            # 2. Move corrected dicoms into original dcm2niix input directory
+            for dicom in glob.glob(corrected_dcm_dir + "/**"):
+                shutil.move(dicom, dcm2niix_input_dir)
 
-            else:
-                # If dcm2niix input directory is empty:
-                # 1. Remove orphan directory
-                shutil.rmtree(orphan_dcm)
-
-                # 2. Move corrected dicoms into original dcm2niix input directory
-                dicoms = glob.glob(corrected_dcm_dir + "/**")
-                for file in dicoms:
-                    shutil.move(file, dcm2niix_input_dir)
-
-                # 3. Remove corrected dicoms directory
-                shutil.rmtree(corrected_dcm_dir)
+            # 3. Remove corrected dicoms directory
+            shutil.rmtree(corrected_dcm_dir)
         else:
             log.info(
-                (
-                    "No file removal performed. "
-                    "No dicoms from incomplete volumes were found."
-                )
+                "No file removal performed. No dicoms from incomplete volumes were "
+                "found."
             )
 
-        n_dicom_files = len(glob.glob(dcm2niix_input_dir + "/*"))
         log.info(
-            (
-                f"{n_dicom_files} dicom files remain. "
-                "Completed incomplete volume correction."
-            )
+            "%d dicom files remain. Completed incomplete volume correction.",
+            len(glob.glob(dcm2niix_input_dir + "/*")),
         )
 
 
 def decompress_dicoms(dcm2niix_input_dir):
     """Implement decompression of dicom files.
 
            For some types of dicom files, compression can be applied to the image data
@@ -108,39 +100,33 @@
         dcm2niix_input_dir (str): The absolute path to a set of dicoms.
 
     Returns:
         None; decompresses dicoms in dc2miix_input_dir.
 
     """
     dicom_files = glob.glob(dcm2niix_input_dir + "/*")
-    n_dicom_files = len(dicom_files)
     log.info(
-        f"Running decompression of dicom files. {n_dicom_files} dicom files found."
+        "Running decompression of dicom files. %d dicom files found.", len(dicom_files)
     )
 
     for file in dicom_files:
-
         # Decompress with gcdmconv in place (overwriting the compressed dicom)
         command = ["gdcmconv", "--raw", file, file]
 
-        process = subprocess.Popen(
+        with subprocess.Popen(
             command,
             stdout=subprocess.PIPE,
             stderr=subprocess.STDOUT,
             universal_newlines=True,
-        )
-
-        if process.wait() != 0:
-            log.info("Output from gdcmconv ...")
-
-            with process.stdout:
-                log.info("\n\n" + process.stdout.read())
-
-            log.error("Error decompressing dicom file using gdcmconv. Exiting.")
-            os.sys.exit(1)
+        ) as process:
+            if process.wait() != 0:
+                log.info("Output from gdcmconv ...")
+                log.info("\n\n %s", process.stdout.read())
+                log.error("Error decompressing dicom file using gdcmconv. Exiting.")
+                os.sys.exit(1)
 
     log.info("Success. Completed decompression of dicom files.")
 
 
 def coil_combine(nifti_files):
     """Implement the coil combined method.
 
@@ -156,25 +142,23 @@
         "Expert Option (coil_combine). "
         "We trust that since you have selected this option "
         "you know what you are asking for. "
         "Continuing."
     )
 
     for nifti_file in nifti_files:
-
         try:
-
-            log.info(f"Start implementing coil combined method for {nifti_file}")
+            log.info("Start implementing coil combined method for %s", nifti_file)
             n1 = nb.load(nifti_file)
-            d1 = n1.get_data()
+            d1 = n1.get_fdata()
             d2 = d1[..., -1]
             n2 = nb.Nifti1Image(d2, n1.get_affine(), header=n1.get_header())
             nb.save(n2, nifti_file)
-            log.info(f"Generated coil combined data for {nifti_file}")
+            log.info("Generated coil combined data for %s", nifti_file)
 
+        # pylint: disable-next=broad-except
         except Exception as e:
-
             log.error(
-                f"Could not generate coil combined data for {nifti_file}. Exiting."
+                "Could not generate coil combined data for %s. Exiting.", nifti_file
             )
             log.exception(e)
             os.sys.exit(1)
```

## fw_gear_dcm2niix/dcm2niix/interfaces.py

```diff
@@ -1,38 +1,56 @@
-"""The interfaces module
-Temporary resolution to fix bug with dcm2niix not escaping metacharacters in filename.
+"""The interfaces module.
+
+Temporary resolution to include mvec files in output.
 """
-import glob
 import os
-import re
 from copy import deepcopy
 
-from nipype.interfaces.base import traits
-from nipype.interfaces.dcm2nii import Dcm2niix, Dcm2niixInputSpec
+from nipype.interfaces.base import File, OutputMultiPath, traits
+from nipype.interfaces.dcm2nii import (
+    Dcm2niix,
+    Dcm2niixInputSpec,
+    Dcm2niixOutputSpec,
+    search_files,
+)
 
 
 class Dcm2niixInputSpecEnhanced(Dcm2niixInputSpec):
+    # pylint: disable=too-many-instance-attributes
+    """Dcm2niixInputSpecEnhanced class."""
+
     # Current dcm2niix NiPype interface does not support the merge2d
     merge_imgs = traits.Enum(
         0,
         1,
         2,
         default=2,
         argstr="-m %s",
         desc="merge 2D slices from same series regardless of echo, exposure, etc. "
         "(0=no, 1=yes, 2=auto, default 2)",
     )
 
 
+class Dcm2niixOutputSpecEnhanced(Dcm2niixOutputSpec):
+    """Dcm2niixInputSpecEnhanced class."""
+
+    # Current dcm2niix NiPype interface does not support mvec.
+    # Nipype ticket submitted, https://github.com/nipy/nipype/issues/3553
+    mvecs = OutputMultiPath(File(exists=True))
+
+
 class Dcm2niixEnhanced(Dcm2niix):
+    # pylint: disable=abstract-method
+    """Dcm2niixEnhanced class."""
 
     input_spec = Dcm2niixInputSpecEnhanced
+    output_spec = Dcm2niixOutputSpecEnhanced
 
     def _format_arg(self, opt, spec, val):
-        """Same as parent but without merge_imgs"""
+        """Same as parent but without merge_imgs."""
         bools = [
             "bids_format",
             "single_file",
             "verbose",
             "crop",
             "has_private",
             "anon_bids",
@@ -45,24 +63,50 @@
             if val:
                 spec.argstr += " y"
             else:
                 spec.argstr += " n"
                 val = True
         if opt == "source_names":
             return spec.argstr % (os.path.dirname(val[0]) or ".")
-        return super(Dcm2niix, self)._format_arg(opt, spec, val)
+        return super()._format_arg(opt, spec, val)
 
-    def _parse_stdout(self, stdout):
-        filenames = []
-        for line in stdout.split("\n"):
-            # if line.startswith("Convert "):  # output
-            if "Convert " in line:  # output
-                # dcm2niix stdout has a formatting issue that leads to lines that reads like
-                # "Warning: Intensity scale/slope using 0028,1053 and 0028,1052Convert 1 DICOM as /flywheel/v0/work/..."
-                # and "scale/slope" gets incorrectly extracted as a filepath
-                # PR submitted to dcm2niix https://github.com/rordenlab/dcm2niix/pull/584
-                res = re.findall(r"\S+/\S+", line)
-                fname = [s for s in res if s != "scale/slope"][0]
-                # Temporary fix - MR on nipype to fix this issue https://github.com/nipy/nipype/pull/3417
-                fname = glob.escape(fname)
-                filenames.append(os.path.abspath(fname))
-        return filenames
+    def _parse_files(self, filenames):
+        """Adds mvec to filetypes"""
+        outfiles, bvals, bvecs, mvecs, bids = [], [], [], [], []
+        outtypes = [".bval", ".bvec", ".mvec", ".json", ".txt"]
+        if self.inputs.to_nrrd:
+            outtypes += [".nrrd", ".nhdr", ".raw.gz"]
+        else:
+            outtypes += [".nii", ".nii.gz"]
+        for filename in filenames:
+            # search for relevant files, and sort accordingly
+            for fl in search_files(filename, outtypes):
+                if (
+                    fl.endswith(".nii")
+                    or fl.endswith(".gz")
+                    or fl.endswith(".nrrd")
+                    or fl.endswith(".nhdr")
+                ):
+                    outfiles.append(fl)
+                elif fl.endswith(".bval"):
+                    bvals.append(fl)
+                elif fl.endswith(".bvec"):
+                    bvecs.append(fl)
+                elif fl.endswith(".mvec"):
+                    mvecs.append(fl)
+                elif fl.endswith(".json") or fl.endswith(".txt"):
+                    bids.append(fl)
+        self.output_files = outfiles
+        self.bvecs = bvecs
+        self.mvecs = mvecs
+        self.bvals = bvals
+        self.bids = bids
+
+    def _list_outputs(self):
+        """Adds mvecs to output"""
+        outputs = self.output_spec().trait_get()
+        outputs["converted_files"] = self.output_files
+        outputs["bvecs"] = self.bvecs
+        outputs["bvals"] = self.bvals
+        outputs["mvecs"] = self.mvecs
+        outputs["bids"] = self.bids
+        return outputs
```

## fw_gear_dcm2niix/utils/__init__.py

```diff
@@ -0,0 +1,2 @@
+00000000: 2222 2275 7469 6c73 2073 7562 2d6d 6f64  """utils sub-mod
+00000010: 756c 652e 2222 220a                      ule.""".
```

## fw_gear_dcm2niix/utils/metadata.py

```diff
@@ -3,15 +3,14 @@
 
 import json
 import logging
 import os
 import pprint
 from pathlib import Path
 
-import pydicom
 from flywheel_gear_toolkit.utils.file import sanitize_filename
 from fw_gear_file_metadata_importer.files.dicom import (
     get_dicom_header,
     preprocess_input,
 )
 
 log = logging.getLogger(__name__)
@@ -21,131 +20,123 @@
     output_image_files,
     output_sidecar_files,
     work_dir,
     dcm2niix_input_dir=None,
     retain_sidecar=False,
     retain_nifti=True,
     output_nrrd=False,
-    pydeface_intermediaries=False,
     classification=None,
     modality=None,
 ):
+    # pylint: disable=too-many-arguments
     """Generate file metadata from dcm2niix output.
 
         Using the BIDS json sidecar output from dcm2niix, generate file metadata
-        (file.info) and set the classification (file.measurements) from the input
-        configuration settings.
+        (file.info.header.dicom) and set the classification (file.measurements)
+        from the input configuration settings.
 
     Args:
         output_image_files (list): The absolute paths to converted image files to resolve.
             Typically these are NIfTI files, but can be the two files constituting the
             NRRD format (i.e., ".raw" and ".nhdr") or the NRRD format (i.e., ".nrrd").
-            Also contains ".bvals" and ".bvecs", if applicable.
+            Also contains ".bval", ".bvec", and ".mvec" files, if applicable.
         output_sidecar_files (list): The absolute paths to the sidecar files to be
             used as metadata on all files in the output_image_files input list.
         work_dir (str): The absolute path to the output directory of dcm2niix and where
             the metadata file generated is written to.
         dcm2niix_input_dir (str): The absolute path to a set of dicoms as input
             to dcm2niix.
         retain_sidecar (bool): If true, sidecar is retained in final output.
         retain_nifti (bool): If true, nifti is retained in final output.
         output_nrrd (bool): If true, export as NRRD instead of NIfTI.
-        pydeface_intermediaries (bool): If True, pydeface intermediary files are
-            retained. The files created when --nocleanup flag is applied to the
-            pydeface command.
         classification (dict): File classification, typically from gear config.
         modality (str): File modality, typically from gear config.
 
     Returns:
         metadata_file (str): The absolute path to the metadata file generated.
 
     """
+    # pylint: disable=duplicate-code
     metadata = capture(
         output_image_files,
         output_sidecar_files,
-        work_dir,
         dcm2niix_input_dir=dcm2niix_input_dir,
         retain_sidecar=retain_sidecar,
         retain_nifti=retain_nifti,
         output_nrrd=output_nrrd,
-        pydeface_intermediaries=pydeface_intermediaries,
         classification=classification,
         modality=modality,
     )
+    # pylint: enable=duplicate-code
 
     metadata_file = create_file(metadata, work_dir)
 
     log.info("Metadata generation completed successfully.")
     metadata_formatted = pprint.pformat(metadata)
-    log.info(f"Metadata contents: \n\n{metadata_formatted}\n")
+    log.info("Metadata contents: \n\n%s\n", metadata_formatted)
 
     return metadata_file
 
 
 def capture(
     output_image_files,
     output_sidecar_files,
-    work_dir,
     dcm2niix_input_dir=None,
     retain_sidecar=True,
     retain_nifti=True,
     output_nrrd=False,
-    pydeface_intermediaries=False,
     classification=None,
     modality=None,
 ):
+    # pylint: disable=too-many-branches,too-many-statements,too-many-locals,too-many-arguments
     """Capture file metadata for each dcm2niix output.
 
         Using the BIDS json sidecar output from dcm2niix, generate file metadata
-        (file.info) and set the classification (file.measurements) from the input
-        configuration settings.
+        (file.info.header.dicom) and set the classification (file.measurements)
+        from the input configuration settings.
 
     Args:
         output_image_files (list): The absolute paths to converted image files to resolve.
             Typically these are NIfTI files, but can be the two files constituting the
             NRRD format (i.e., ".raw" and ".nhdr") or the NRRD format (i.e., ".nrrd").
-            Also contains ".bvals" and ".bvecs", if applicable.
+            Also contains ".bval", ".bvec", and ".mvec" files, if applicable.
         output_sidecar_files (list): The absolute paths to the sidecar files to be
             used as metadata on all files in the output_image_files input list.
         work_dir (str): The absolute path to the output directory of dcm2niix and where
             the metadata file generated is written to.
         dcm2niix_input_dir (str): The absolute path to a set of dicoms as input
             to dcm2niix.
         retain_sidecar (bool): If true, sidecar is retained in final output.
         retain_nifti (bool): If true, nifti is retained in final output.
         output_nrrd (bool): If true, export as NRRD instead of NIfTI.
-        pydeface_intermediaries (bool): If True, pydeface intermediary files are
-            retained. The files created when --nocleanup flag is applied to the
-            pydeface command.
         classification (dict): File classification, typically from gear config.
         modality (str): File modality, typically from gear config.
 
     Returns:
         metadata (dict): Structured metadata information for a given file set.
 
     """
     log.info("Capturing metadata.")
 
     if (retain_nifti and output_nrrd) or (
         not retain_nifti and not output_nrrd and not retain_sidecar
     ):
+        # pylint: disable=duplicate-code
         log.critical(
             "Function arguments retain_nifti and output_nrrd are exclusive. "
             "Gear config logic is broken. Exiting."
         )
         os.sys.exit(1)
 
     capture_metadata = []
 
     # Collate metadata from dicom header and from the associated bids sidecar
 
     for sidecar in output_sidecar_files:
-
         with open(sidecar, encoding="utf-8") as sidecar_file:
-
             sidecar_info = json.load(sidecar_file, strict=False)
 
             # Capture the fields required to select a single DICOM for metadata
             try:
                 series_description = sidecar_info["SeriesDescription"]
             except KeyError:
                 series_description = ""
@@ -153,17 +144,16 @@
                 series_number = str(sidecar_info["SeriesNumber"])
             except KeyError:
                 series_number = ""
 
             # Retain the modality set in the config; otherwise, replace with sidecar
             # captured modality determined via dcm2niix and if neither modality set
             # in the config or sidecar, then set modality to MR.
-            if modality is None:
-                if "Modality" in sidecar_info:
-                    modality = sidecar_info["Modality"]
+            if (modality is None) and ("Modality" in sidecar_info):
+                modality = sidecar_info["Modality"]
 
         # Using the unique set of SeriesDescription and SeriesNumber from the DICOM
         # header, capture additional metadata.
         dicom_data = {}
         if dcm2niix_input_dir:
             log.info("Capturing additional metadata from DICOMs.")
 
@@ -171,113 +161,81 @@
                 path
                 for path in Path(dcm2niix_input_dir).rglob("*")
                 if not path.is_dir()
             ]
             for dicom in dicoms:
                 file_, _ = preprocess_input(dicom)
                 dicom_data = get_dicom_header(file_)
-                if dicom_data.get("SeriesDescription"):
-                    dicom_series_description = dicom_data.get(
-                        "SeriesDescription"
-                    ).replace(" ", "_")
-                else:
-                    dicom_series_description = ""
-
+                dicom_series_description = dicom_data.get(
+                    "SeriesDescription", ""
+                ).replace(" ", "_")
                 dicom_series_number = str(dicom_data.get("SeriesNumber"))
 
                 if (dicom_series_description == series_description) and (
                     dicom_series_number == series_number
                 ):
                     break
-                else:
-                    continue
+                # else:
+                continue
 
         else:
             log.info("Unable to capture additional metadata from DICOMs.")
 
         # Remove metadata with None value
         dicom_data = {k: v for k, v in dicom_data.items() if v is not None}
-
-        # Collate metadata from dicom header and dcm2niix sidecar into one dictionary
-        metadata = {**sidecar_info, **dicom_data}
         log.debug("Structured metadata captured.")
 
         # Apply collated metadata to all associated files
 
         # Sidecar file
-        if retain_sidecar:
-            filedata = create_file_metadata(
-                sidecar, "source code", classification, metadata, modality
-            )
-            capture_metadata.append(filedata)
+        filedata = create_file_metadata(
+            sidecar, "source code", classification, dicom_data, modality
+        )
+        capture_metadata.append(filedata)
 
         # Data files
         # Split sidecar into the "root" name by removing .json suffix
-        stem = sidecar.split(".json")[0]
+        stem = sidecar.removesuffix(".json")
         for file in output_image_files:
+            # pylint: disable=duplicate-code
             # Split image name by "root" name from sidecar
             substr = file.split(stem)
             # If the "root" name of sidecar is not a substring of image file
             #   We don't care about this image file.
             if len(substr) < 2:
                 continue
             # Get "root" and what's "left" over after splitting of "root" name
             #   from sidecar
             _, left = substr
+            # pylint: enable=duplicate-code
 
             if retain_nifti:
-
                 # NIfTI
                 if left in [".nii.gz", ".nii"]:
                     filedata = create_file_metadata(
-                        file, "nifti", classification, metadata, modality
-                    )
-                    capture_metadata.append(filedata)
-
-                # bval
-                if left in [".bval"]:
-                    filedata = create_file_metadata(
-                        file, "bval", classification, metadata, modality
+                        file, "nifti", classification, dicom_data, modality
                     )
                     capture_metadata.append(filedata)
 
-                # bvec
-                if left in [".bvec"]:
+                # bval, bvec, and mvec:
+                elif left in [".bval", ".bvec", ".mvec"]:
+                    # (left[1:] removes the initial "." from the string)
                     filedata = create_file_metadata(
-                        file, "bvec", classification, metadata, modality
+                        file, left[1:], classification, dicom_data, modality
                     )
                     capture_metadata.append(filedata)
 
             if output_nrrd:
-
                 # NRRD
                 if left in [".raw.gz", ".nhdr", ".nrrd"]:
                     filedata = create_file_metadata(
-                        file, "nrrd", classification, metadata, modality
+                        file, "nrrd", classification, dicom_data, modality
                     )
                     capture_metadata.append(filedata)
 
-        # PyDeface files
-        if pydeface_intermediaries:
-
-            # The output mask of PyDeface is a compressed nifti, even if .nii input
-            file = os.path.join(work_dir, f"{Path(sidecar).stem}_pydeface_mask.nii.gz")
-            if os.path.isfile(file):
-                filedata = create_file_metadata(
-                    file, "nifti", classification, metadata, modality
-                )
-                capture_metadata.append(filedata)
-
-            file = os.path.join(work_dir, f"{Path(sidecar).stem}_pydeface.mat")
-            if os.path.isfile(file):
-                filedata = create_file_metadata(
-                    file, "MATLAB data", classification, metadata, modality
-                )
-                capture_metadata.append(filedata)
-
     # If modality is not set, remove modality and classification from the metadata file
     if modality is None:
         for file in capture_metadata:
             file.pop("modality")
             file.pop("classification")
 
     # If classification is not set, remove classification from the metadata file
@@ -285,22 +243,21 @@
         for file in capture_metadata:
             try:
                 file.pop("classification")
             except KeyError:
                 continue
 
     # Collate the metadata and write to file
-    metadata = {}
-    metadata["acquisition"] = {}
-    metadata["acquisition"]["files"] = capture_metadata
+    metadata = {"acquisition": {"files": capture_metadata}}
 
     return metadata
 
 
 def dicom_metadata_extraction(dicom_header):
+    # pylint: disable=too-many-branches,too-many-statements
     """Extract metadata from a dicom file header.
 
     Args:
         dicom_header (pydicom.dataset.FileDataset): A PyDicom header of a DICOM file.
 
     Returns:
         dicom_data (dict): Extracted dicom headers with their values.
@@ -404,33 +361,32 @@
         dicom_data["ScanType"] = dicom_header[0x2005, 0x10A1].value
     except (AttributeError, KeyError):
         dicom_data["ScanType"] = None
 
     return dicom_data
 
 
-def create_file_metadata(filename, filetype, classification, bids_info, modality):
+def create_file_metadata(filename, filetype, classification, dicom_data, modality):
     """Create a dictionary storing the file metadata."""
     filedata = {}
     filedata["name"] = Path(filename).name
     filedata["type"] = filetype
     filedata["classification"] = classification
-    filedata["info"] = bids_info
+    filedata["info"] = {"header": {"dicom": dicom_data}}
     filedata["modality"] = modality
 
     return filedata
 
 
 def serialize_bytes(obj):
+    """Serialize bytes."""
     if isinstance(obj, bytes):
-
         try:
             obj = obj.decode("utf-8")
         except UnicodeDecodeError:
-
             try:
                 obj = obj.decode("latin-1")
             except TypeError:
                 log.critical(
                     "Unable to decode JSON sidecar produced by the dcm2niix tool. Exiting."
                 )
                 os.sys.exit(1)
@@ -439,23 +395,23 @@
 
 
 def create_file(metadata, work_dir):
     """Create metadata file and return path to the created file."""
     log.info("Creating metadata file.")
 
     metadata_file = os.path.join(work_dir, ".metadata.json")
-    with open(metadata_file, "w") as file_obj:
+    with open(metadata_file, "w", encoding="utf-8") as file_obj:
         json.dump(metadata, file_obj, default=serialize_bytes)
 
     log.info("Metadata file created.")
     return metadata_file
 
 
 def rename_infile(infile_path):
     """Sanitize infile name by replacing invalid characters."""
     log.info("Sanitizing filename.")
     f_name = infile_path.name
     sanitized_f_name = sanitize_filename(f_name)
     if sanitized_f_name != f_name:
-        log.debug(f"Renaming filename from {f_name} to {sanitized_f_name} ")
+        log.debug("Renaming filename from %s to %s", f_name, sanitized_f_name)
         os.rename(infile_path.parent / f_name, infile_path.parent / sanitized_f_name)
     return infile_path.parent / sanitized_f_name
```

## fw_gear_dcm2niix/utils/parse_config.py

```diff
@@ -8,53 +8,57 @@
 
 from fw_gear_dcm2niix.utils.metadata import rename_infile
 
 log = logging.getLogger(__name__)
 
 
 def generate_gear_args(gear_context, FLAG):
+    # pylint: disable=too-many-branches,too-many-statements
     """Generate gear arguments for different stages indicated by the FLAG."""
-    log.info(f"{100*'-'}")
-    log.info(f"Preparing arguments for gear stage >> {FLAG}.")
+    log.info("%s", 100 * "-")
+    log.info("Preparing arguments for gear stage >> %s", FLAG)
 
     if FLAG == "prepare":
-
         infile = gear_context.get_input_path("dcm2niix_input")
         try:
-            with open(infile, "r") as f:
-                log.debug(f"{f} opened from dcm2niix_input.")
+            with open(infile, "r", encoding="utf-8") as f:
+                log.debug("%s opened from dcm2niix_input.", f)
 
         except FileNotFoundError:
             # Path separation in filename may cause downloaded filename to be altered
             filename = (
                 gear_context.config_json.get("inputs", {})
                 .get("dcm2niix_input", {})
                 .get("location", {})
                 .get("name")
             )
-            if len(filename.split("/")) > 1:
-                infile = f"/flywheel/v0/input/dcm2niix_input/{filename.split('/')[-1]}"
+            try:
+                if len(filename.split("/")) > 1:
+                    infile = (
+                        f"/flywheel/v0/input/dcm2niix_input/{filename.split('/')[-1]}"
+                    )
 
-                try:
-                    with open(infile, "r"):
+                    with open(infile, "r", encoding="utf-8"):
                         log.debug(
-                            f"{infile} opened from path separated dcm2niix_input."
+                            "%s opened from path separated dcm2niix_input.", infile
                         )
-                except FileNotFoundError:
-                    log.info(
-                        f"Path to dcm2niix_input: {gear_context.get_input_path('dcm2niix_input')}"
-                    )
-                    log.error(
-                        "Filename not understood from Gear context. Unable to open dcm2niix_input. Exiting."
-                    )
-                    os.sys.exit(1)
+            except (FileNotFoundError, AttributeError):
+                log.info(
+                    "Path to dcm2niix_input: %s",
+                    gear_context.get_input_path("dcm2niix_input"),
+                )
+                log.error(
+                    "Filename not understood from Gear context. Unable to open dcm2niix_input. Exiting."
+                )
+                os.sys.exit(1)
 
         except UnicodeEncodeError:
             log.info(
-                f"Path to dcm2niix_input: {gear_context.get_input_path('dcm2niix_input')}"
+                "Path to dcm2niix_input: %s",
+                gear_context.get_input_path("dcm2niix_input"),
             )
             log.error(
                 "Filename not understood from Gear context. Unable to open dcm2niix_input. Exiting."
             )
             os.sys.exit(1)
 
         # Rename infile if outfile is using infile folder
@@ -71,35 +75,43 @@
                 "remove_incomplete_volumes"
             ],
             "decompress_dicoms": gear_context.config["decompress_dicoms"],
             "rec_infile": None,
         }
 
         if gear_context.get_input_path("rec_file_input"):
-
             rec_infile = Path(gear_context.get_input_path("rec_file_input"))
-            if rec_infile.is_file():
-                gear_args["rec_infile"] = str(rec_infile)
-            else:
+            if not rec_infile.is_file():
                 log.error(
                     "Configuration for rec_infile_input is not a valid path. Exiting."
                 )
                 os.sys.exit(1)
+            # else:
+            gear_args["rec_infile"] = str(rec_infile)
 
     elif FLAG == "dcm2niix":
-
         # Notice the explicit 'y' for bids_sidecar, in order to capture metadata; the
-        # user-defined config option setting wil be considered during the gear resolve stage.
+        # user-defined config option setting wil be considered during the gear resolve
+        # stage.
         filename = gear_context.config["filename"]
+        # If filename is "%dicom%", use the dicom filename (without extension) as
+        # output filename:
+        if filename == "%dicom%":
+            filename = Path(gear_context.get_input_path("dcm2niix_input")).stem
+            # if there is still a ".dcm" extension, remove it:
+            filename = filename.removesuffix(".dcm")
         filename = filename.replace(" ", "_")
 
         comment = gear_context.config["comment"]
         if len(comment) > 24:
             log.error(
-                f"The comment configuration option must be less than 25 characters. You have entered {len(comment)} characters. Please edit and resubmit Gear. Exiting."
+                "The comment configuration option must be less than 25 characters. "
+                "You have entered %d characters. Please edit and resubmit Gear. "
+                "Exiting.",
+                len(comment),
             )
             os.sys.exit(1)
 
         gear_args = {
             "anonymize_bids": gear_context.config["anonymize_bids"],
             "bids_sidecar": "y",
             "comment": comment,
@@ -115,99 +127,55 @@
             "output_nrrd": gear_context.config["output_nrrd"],
             "philips_scaling": gear_context.config["philips_scaling"],
             "single_file_mode": gear_context.config["single_file_mode"],
             "text_notes_private": gear_context.config["text_notes_private"],
             "verbose": gear_context.config["dcm2niix_verbose"],
         }
 
-        # Anonymization cascade
-        if gear_context.config["pydeface"]:
-            gear_args["anonymize_bids"] = True
-            gear_args["text_notes_private"] = False
-
-    elif FLAG == "pydeface":
-
-        gear_args = {
-            "pydeface_cost": gear_context.config["pydeface_cost"],
-            "template": None,
-            "facemask": None,
-            "pydeface_nocleanup": gear_context.config["pydeface_nocleanup"],
-            "pydeface_verbose": gear_context.config["pydeface_verbose"],
-        }
-
-        if gear_context.get_input_path("pydeface_template"):
-            pydeface_template = Path(gear_context.get_input_path("pydeface_template"))
-            if pydeface_template.is_file():
-                gear_args["template"] = pydeface_template
-                log.info(f"Found input template for pydeface: {gear_args['template']}")
-            else:
-                log.error(
-                    "Configuration for pydeface_template is not a valid path. Exiting."
-                )
-                os.sys.exit(1)
-        else:
-            log.info("No input template provided for pydeface. Defaults assumed.")
-
-        if gear_context.get_input_path("pydeface_facemask"):
-            pydeface_facemask = Path(gear_context.get_input_path("pydeface_facemask"))
-            if pydeface_facemask.is_file():
-                gear_args["facemask"] = pydeface_facemask
-                log.info(f"Found input facemask for pydeface: {gear_args['facemask']}")
-            else:
-                log.error(
-                    "Configuration for pydeface_facemask is not a valid path. Exiting."
-                )
-                os.sys.exit(1)
-        else:
-            log.info("No input facemask provided for pydeface. Defaults assumed.")
-
     elif FLAG == "resolve":
         gear_args = {
             "ignore_errors": gear_context.config["ignore_errors"],
             "retain_sidecar": True,
             "retain_nifti": True,
             "output_nrrd": gear_context.config["output_nrrd"],
-            "pydeface_intermediaries": False,
             "classification": None,
             "modality": None,
         }
 
-        if gear_context.config["bids_sidecar"] == "n":
-            gear_args["retain_sidecar"] = False
-
-        if gear_context.config["bids_sidecar"] == "o":
-            gear_args["retain_nifti"] = False
-
-        if gear_context.config["pydeface_nocleanup"]:
-            gear_args["pydeface_intermediaries"] = True
-
-        if gear_context.config["output_nrrd"]:
+        if (
+            gear_context.config["bids_sidecar"] in ("n", "o")
+            or gear_context.config["output_nrrd"]
+        ):
             gear_args["retain_nifti"] = False
 
         try:
             classification = (
                 gear_context.config_json.get("inputs", {})
                 .get("dcm2niix_input", {})
                 .get("object", {})
                 .get("classification")
             )
             # If modality is set and classification is not set, classification returned as {'Custom':[]}
             # If modality and classification are not set, classification returned as {}
-            if classification != {} and classification != {"Custom": []}:
+            if classification not in ({}, {"Custom": []}):
                 gear_args["classification"] = classification
         except KeyError:
             log.info("Cannot determine classification from configuration.")
 
         try:
             gear_args["modality"] = (
                 gear_context.config_json.get("inputs", {})
                 .get("dcm2niix_input", {})
                 .get("object", {})
                 .get("modality")
             )
         except KeyError:
             log.info("Cannot determine modality from configuration.")
 
+        tag = gear_context.config.get("tag", "")
+        if tag != "":
+            gear_args["tag"] = tag
+
     gear_args_formatted = pprint.pformat(gear_args)
-    log.info(f"Prepared gear stage arguments: \n\n{gear_args_formatted}\n")
+    log.info("Prepared gear stage arguments: \n\n%s\n", gear_args_formatted)
 
     return gear_args
```

## fw_gear_dcm2niix/utils/resolve.py

```diff
@@ -1,13 +1,12 @@
 """Functions to resolve dcm2niix gear outputs."""
 
 import logging
 import os
 import shutil
-from pathlib import Path
 
 from fw_gear_dcm2niix.utils import metadata
 
 log = logging.getLogger(__name__)
 
 
 def setup(
@@ -16,130 +15,118 @@
     work_dir,
     dcm2niix_input_dir,
     output_dir,
     ignore_errors=False,
     retain_sidecar=False,
     retain_nifti=True,
     output_nrrd=False,
-    pydeface_intermediaries=False,
     classification=None,
     modality=None,
 ):
+    # pylint: disable=too-many-arguments,too-many-locals
     """Orchestrate resolution of gear, including metadata capture and file retention.
 
     Args:
         output_image_files (list): The absolute paths to converted image files to resolve.
             Typically these are NIfTI files, but can be the two files constituting the
             NRRD format (i.e., ".raw" and ".nhdr") or the NRRD format (i.e., ".nrrd").
-            Also contains ".bvals" and ".bvecs", if applicable.
+            Also contains ".bval", ".bvec", and ".mvec" files, if applicable.
         output_sidecar_files (list): The absolute paths to the sidecar files to be
             used as metadata on all files in the output_image_files input list.
         work_dir (str): The absolute path to the output directory of dcm2niix and where
             the metadata file generated is written to.
         dcm2niix_input_dir (str): The absolute path to the input directory to dcm2niix.
         retain_sidecar (bool): If true, sidecar is retained in final output.
         retain_nifti (bool): If true, NIfTI is retained in final output.
         output_nrrd (bool): If true, export as NRRD instead of NIfTI.
-        pydeface_intermediaries (bool): If true, PyDeface intermediary files are
-            retained. The files created when --nocleanup flag is applied to the
-            PyDeface command.
         classification (dict): File classification, typically from gear config.
         modality (str): File modality, typically from gear config.
 
     Returns:
         None
 
     """
     # Ignoring errors configuration option; move all files from work_dir to output_dir
     if ignore_errors is True:
         log.warning("Applying Expert Option (ignore_errors).")
 
         if output_image_files is not None:
-
             # Capture metadata
-            metadata_file = metadata.generate(
+            _ = metadata.generate(
                 output_image_files,
                 output_sidecar_files,
                 work_dir,
                 dcm2niix_input_dir,
                 retain_sidecar=True,
                 retain_nifti=True,
                 output_nrrd=False,
-                pydeface_intermediaries=pydeface_intermediaries,
                 classification=classification,
                 modality=modality,
             )
 
-        work_dir_contents = os.listdir(work_dir)
-        for item in work_dir_contents:
+        for item in os.listdir(work_dir):
             item_path = os.path.join(work_dir, item)
             if not os.path.isdir(item_path):
                 shutil.move(item_path, output_dir)
-                log.info(f"Moving {item} to output directory for upload to Flywheel.")
+                log.info("Moving %s to output directory for upload to Flywheel.", item)
 
     else:
-
         # Capture metadata
+        # pylint: disable=duplicate-code
         metadata_file = metadata.generate(
             output_image_files,
             output_sidecar_files,
             work_dir,
             dcm2niix_input_dir,
             retain_sidecar=retain_sidecar,
             retain_nifti=retain_nifti,
             output_nrrd=output_nrrd,
-            pydeface_intermediaries=pydeface_intermediaries,
             classification=classification,
             modality=modality,
         )
+        # pylint: enable=duplicate-code
 
         # Retain gear outputs
         retain_gear_outputs(
             output_image_files,
             output_sidecar_files,
             metadata_file,
-            work_dir,
             output_dir,
             retain_sidecar=retain_sidecar,
             retain_nifti=retain_nifti,
             output_nrrd=output_nrrd,
-            pydeface_intermediaries=pydeface_intermediaries,
         )
 
 
 def retain_gear_outputs(
     output_image_files,
     output_sidecar_files,
     metadata_file,
-    work_dir,
     output_dir,
     retain_sidecar=True,
     retain_nifti=True,
     output_nrrd=False,
-    pydeface_intermediaries=False,
 ):
+    # pylint: disable=too-many-arguments
     """Move selected gear outputs to the output directory.
 
     Args:
         output_image_files (list): The absolute paths to converted image files to resolve.
             Typically these are NIfTI files, but can be the two files constituting the
             NRRD format (i.e., ".raw" and ".nhdr") or the NRRD format (i.e., ".nrrd").
-            Also contains ".bvals" and ".bvecs", if applicable.
+            Also contains ".bval", ".bvec", and ".mvec" files, if applicable.
         output_sidecar_files (list): The absolute paths to the sidecar files to be
             used as metadata on all files in the output_image_files input list.
         metadata_file (str): The absolute path to the metadata file.
         work_dir (str): The absolute path to the output directory of dcm2niix and
             where the generated metadata file is.
         output_dir (str): The absolute path to the gear output directory.
         retain_sidecar (bool): If true, sidecar is retained in final output.
         retain_nifti (bool): If true, NIfTI is retained in final output.
         output_nrrd (bool): If true, export as NRRD instead of NIfTI.
-        pydeface_intermediaries (bool): If true, pydeface intermediary files are
-            retained. The files created when --nocleanup flag is applied to the
-            pydeface command.
 
     Returns:
         None
 
     """
     log.info("Resolving gear outputs.")
 
@@ -149,60 +136,47 @@
         log.critical(
             "Function arguments retain_nifti and output_nrrd are exclusive. "
             "Gear config logic is broken. Exiting."
         )
         os.sys.exit(1)
 
     for sidecar in output_sidecar_files:
-
         # Move bids json sidecar file, if indicated
         if retain_sidecar:
             shutil.move(sidecar, output_dir)
-            log.info(f"Moving {sidecar} to output directory.")
+            log.info("Moving %s to output directory.", sidecar)
 
         # Move data files, if indicated
         # Split sidecar into the "root" name by removing .json suffix
         stem = sidecar.split(".json")[0]
         for file in output_image_files:
+            # pylint: disable=duplicate-code
             # Split image name by "root" name from sidecar
             substr = file.split(stem)
             # If the "root" name of sidecar is not a substring of image file
             #   We don't care about this image file.
             if len(substr) < 2:
                 continue
             # Get "root" and what's "left" over after splitting of "root" name
             #   from sidecar
             _, left = substr
+            # pylint: enable=duplicate-code
 
             if retain_nifti:
                 # If "left" over is simply the extension, this image matches
                 #   the current sidecar, move to output.
-                if left in [".nii.gz", ".nii", ".bval", ".bvec"]:
-                    log.info(f"Moving {file} to output directory.")
+                if left in [".nii.gz", ".nii", ".bval", ".bvec", ".mvec"]:
+                    log.info("Moving %s to output directory.", file)
                     shutil.move(file, output_dir)
 
             if output_nrrd:
                 # If "left" over is simply the extension, this image matches
                 #   the current sidecar, move to output.
                 if left in [".raw.gz", ".nhdr", ".nrrd"]:
-                    log.info(f"Moving {file} to output directory.")
+                    log.info("Moving %s to output directory.", file)
                     shutil.move(file, output_dir)
 
-        # PyDeface files
-        if pydeface_intermediaries:
-
-            # The output mask of PyDeface is a compressed nifti, even if .nii input
-            file = os.path.join(work_dir, f"{Path(sidecar).stem}_pydeface_mask.nii.gz")
-            if os.path.isfile(file):
-                log.info(f"Moving {file} to output directory.")
-                shutil.move(file, output_dir)
-
-            file = os.path.join(work_dir, f"{Path(sidecar).stem}_pydeface.mat")
-            if os.path.isfile(file):
-                log.info(f"Moving {file} to output directory.")
-                shutil.move(file, output_dir)
-
     # Move metadata file
     shutil.move(metadata_file, output_dir)
-    log.info(f"Moving {metadata_file} to output directory.")
+    log.info("Moving %s to output directory.", metadata_file)
 
     log.info("Gear outputs resolved.")
```

## Comparing `fw_gear_dcm2niix-1.4.1.dist-info/RECORD` & `fw_gear_dcm2niix-2.0.0.dist-info/RECORD`

 * *Files 23% similar despite different names*

```diff
@@ -1,16 +1,15 @@
-fw_gear_dcm2niix/__init__.py,sha256=Vy8d6J5bfEir2fSLUb6jHb3J2qDhJkmk6RoIyI6MM9A,33
-fw_gear_dcm2niix/dcm2niix/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-fw_gear_dcm2niix/dcm2niix/arrange.py,sha256=jr0EVPc__i71Uaqvc2eFaNwHIVA-1uWZs7oZWL3n2C0,14468
-fw_gear_dcm2niix/dcm2niix/dcm2niix_run.py,sha256=8ZuArUldk24ikHn5AhWXLiPg0OjY_dSGsLgoVaizQDs,7570
-fw_gear_dcm2niix/dcm2niix/dcm2niix_utils.py,sha256=jK81B47JyBzy_zVJrvF6VAiktw3agVamNVF-6SQTcAI,5776
-fw_gear_dcm2niix/dcm2niix/interfaces.py,sha256=fvWyeEtLLQMJwIn3GieFH77pspvZrhe7GhtCxEesz80,2371
+fw_gear_dcm2niix/__init__.py,sha256=YaB4aZxevqASxeO3okRaTHvCQVY6DS7BEGVymPgO2dQ,192
+fw_gear_dcm2niix/dcm2niix/__init__.py,sha256=gD5DzU4HJdzPQrsVL3sChft0ymhmdyDtqaPrG2AcX4U,27
+fw_gear_dcm2niix/dcm2niix/arrange.py,sha256=VwfF52hYLsAM5m-UaVoQ098VoTclGpr8vp6ksZHCWvE,14361
+fw_gear_dcm2niix/dcm2niix/dcm2niix_run.py,sha256=GMl_YzdPglMiWb_DRXD7bXqSCKtTXhw5Y2igtwJJAGY,7642
+fw_gear_dcm2niix/dcm2niix/dcm2niix_utils.py,sha256=Bi7FVy2B4qeUJr_57FAM9OjizTRYeDDuLIvzoVEDpf8,5646
+fw_gear_dcm2niix/dcm2niix/interfaces.py,sha256=f-cFwE-W9WAbvXaVptrapXmMgnpXgI0yk7J92d_hUwM,3528
 fw_gear_dcm2niix/dcm2niix/prepare.py,sha256=SXB0Hglz6Y8L0yJ1h61YBFtAZMVtht1c59Iltz3O4II,1240
-fw_gear_dcm2niix/pydeface/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-fw_gear_dcm2niix/pydeface/pydeface_run.py,sha256=-3LMogTTqvi6a99g393qhIfozSqzgZeej4FCqkNolZY,5096
-fw_gear_dcm2niix/utils/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-fw_gear_dcm2niix/utils/metadata.py,sha256=wcheNxTOzV-ZfC0sXDpJatj3fXvy0GprMT14J4h7kbc,16344
-fw_gear_dcm2niix/utils/parse_config.py,sha256=YMdtdj0TRYhj4fbihuPeDk7jcNEfNcaPM6luRO1D8lQ,8428
-fw_gear_dcm2niix/utils/resolve.py,sha256=ktUHpZFKFT3UUbX_XUgEKnXmNpednavERXJ2g4A4jG0,7965
-fw_gear_dcm2niix-1.4.1.dist-info/WHEEL,sha256=DA86_h4QwwzGeRoz62o1svYt5kGEXpoUTuTtwzoTb30,83
-fw_gear_dcm2niix-1.4.1.dist-info/METADATA,sha256=eItDOb2DpT7O7KUpm8QS4h5ADEKH8NcnTJ0QUFumpEA,10806
-fw_gear_dcm2niix-1.4.1.dist-info/RECORD,,
+fw_gear_dcm2niix/utils/__init__.py,sha256=JqFj1MIfZbijg-OcS_ho5QzMfpHEy2G-Pn95dFTlioM,24
+fw_gear_dcm2niix/utils/metadata.py,sha256=ipjsjmZke3xubty-AT73RmaeCOEnIPTTumA-epeBE7k,15016
+fw_gear_dcm2niix/utils/parse_config.py,sha256=Q1AJcBS0rE0FouFVtfun6l627uBUPAI5EQOL2lXdBS4,7078
+fw_gear_dcm2niix/utils/resolve.py,sha256=geyQqxyA_U2LFK1pvZj-l5-g0E0WZrnOH9NBH4ywMNA,6904
+fw_gear_dcm2niix-2.0.0.dist-info/LICENSE,sha256=NNC8xrLtqnhvmkJdOB71ctPp2jBi_2V5u9RzRVEpBcs,1092
+fw_gear_dcm2niix-2.0.0.dist-info/METADATA,sha256=RigPsXWnYwaOhTgnoS1QUizJVFmcE6U243-bUE7E-eQ,13561
+fw_gear_dcm2niix-2.0.0.dist-info/WHEEL,sha256=vVCvjcmxuUltf8cYhJ0sJMRDLr1XsPuxEId8YDzbyCY,88
+fw_gear_dcm2niix-2.0.0.dist-info/RECORD,,
```

